<!DOCTYPE html>
<html>
<head>
  <title>Charger Tester</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: sans-serif;
      background: #f4f4f4;
      padding: 1em;
    }
    #container {
      background: #fff;
      padding: 1em;
      border-radius: 8px;
      max-width: 600px;
      margin: auto;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
    }
    #chargingStatus, #countdownTimer, #testResult {
      font-size: 1.2em;
      text-align: center;
      margin: 0.5em 0;
    }
    #startBtn {
      display: block;
      margin: 1em auto;
      padding: 0.5em 1em;
      font-size: 1em;
      border: none;
      border-radius: 4px;
      color: white;
    }
    #startBtn.red {
      background-color: #d9534f;
    }
    #startBtn.green {
      background-color: #5cb85c;
    }
    #startBtn.blinking {
      animation: blinker 1s linear infinite;
      background-color: #5cb85c;
    }
    @keyframes blinker {
      50% { opacity: 0.4; }
    }
    #logTable {
      display: none;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>Charger Test Logger</h1>
    <div id="chargingStatus">Charging: Unknown</div>
    <div id="countdownTimer"></div>
    <button id="startBtn" class="red" disabled>Connect Charger to Begin</button>
    <table id="logTable">
      <thead>
        <tr><th>Battery %</th><th>Timestamp</th></tr>
      </thead>
      <tbody id="logBody"></tbody>
    </table>
    <div id="testResult">???</div>
  </div>

  <script>
    let batteryRef = null;
    let countdownInterval = null;
    let pollInterval = null;
    let started = false;
    let readings = [];
    let startTime = null;
    const DURATION_MS = 60000;

    const statusEl = document.getElementById("chargingStatus");
    const timerEl = document.getElementById("countdownTimer");
    const startBtn = document.getElementById("startBtn");
    const resultEl = document.getElementById("testResult");

    function resetAllIntervals() {
      clearInterval(countdownInterval);
      clearInterval(pollInterval);
      countdownInterval = null;
      pollInterval = null;
    }

    function updateChargingStatus(isCharging) {
      if (isCharging) {
        statusEl.textContent = "Connected";
        if (!started) {
          startBtn.disabled = false;
          startBtn.textContent = "Begin Test";
          startBtn.className = "green";
        }
      } else {
        statusEl.textContent = "Disconnected";
        startBtn.disabled = true;

        if (started) {
          startBtn.textContent = "Test Aborted!";
          startBtn.className = "red";
          resetTest("???", true);
        } else {
          startBtn.textContent = "Connect Charger to Begin";
          startBtn.className = "red";
          resultEl.textContent = "???";
        }
      }
    }

    function resetTest(message, showResult = false) {
      started = false;
      resetAllIntervals();
      timerEl.textContent = "";
      readings = [];

      resultEl.textContent = "???";  // Always shows ??? unless valid test completes

      if (batteryRef?.charging) {
        startBtn.disabled = false;
        startBtn.textContent = "Begin Test";
        startBtn.className = "green";
      } else {
        startBtn.disabled = true;
        startBtn.textContent = "Connect Charger to Begin";
        startBtn.className = "red";
      }
    }

    function startCountdownTest() {
      resetTest("???");
      readings = [];
      started = true;
      startTime = performance.now();
      resultEl.textContent = "???";

      startBtn.disabled = true;
      startBtn.textContent = "Test in progress";
      startBtn.className = "blinking";

      readings.push({ level: +(batteryRef.level * 100).toFixed(2), time: Date.now() });

      countdownInterval = setInterval(() => {
        const elapsed = performance.now() - startTime;
        const remaining = Math.max(0, DURATION_MS - elapsed);
        const sec = Math.floor(remaining / 1000);
        const ms = Math.floor(remaining % 1000).toString().padStart(3, '0');
        timerEl.textContent = `Time Remaining: ${sec}::${ms}`;

        if (remaining <= 0) {
          resetAllIntervals();
          finalizeTest();
        }
      }, 50);

      pollInterval = setInterval(() => {
        if (batteryRef && started) {
          readings.push({ level: +(batteryRef.level * 100).toFixed(2), time: Date.now() });
        }
      }, 5000);
    }

    function finalizeTest() {
      started = false;
      resetAllIntervals();
      startBtn.textContent = "Begin Test";
      startBtn.className = batteryRef?.charging ? "green" : "red";
      startBtn.disabled = !batteryRef?.charging;

      if (readings.length < 2) {
        resultEl.textContent = "???";
        return;
      }

      const first = readings[0];
      const last = readings[readings.length - 1];
      const deltaPercent = last.level - first.level;
      const deltaTimeMin = (last.time - first.time) / 60000;
      const ratePerMin = deltaPercent / deltaTimeMin;
      const rateDisplay = ratePerMin.toFixed(2);
      resultEl.textContent = `Test complete! Charge rate: ${rateDisplay} %/min (samples: ${readings.length})`;
    }

    startBtn.addEventListener("click", () => {
      if (batteryRef?.charging) {
        startCountdownTest();
      }
    });

    if ('getBattery' in navigator) {
      navigator.getBattery().then(battery => {
        batteryRef = battery;
        updateChargingStatus(battery.charging);

        battery.addEventListener('chargingchange', () => {
          updateChargingStatus(battery.charging);
        });
      });
    } else {
      statusEl.textContent = "Battery API not supported in this browser.";
    }
  </script>
</body>
</html>
